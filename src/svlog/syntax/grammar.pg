/////////////////////////
//   A.1 Source text   //
/////////////////////////

// A.1.2 SystemVerilog source text

pub source_text = timeunits_declaration? description*;
description = {
    module_declaration,
    udp_declaration,
    interface_declaration,
    program_declaration,
    package_declaration,
    attribute_instance* package_item,
    attribute_instance* bind_directive,
    config_declaration,
};
module_declaration = {
    module_nonansi_header timeunits_declaration? module_item* 'endmodule' (':' module_identifier)?,
    module_ansi_header timeunits_declaration? non_port_module_item* 'endmodule' (':' module_identifier)?,
    attribute_instance* module_keyword lifetime? module_identifier package_import_declaration*! parameter_port_list?! '(' attribute_instance*! '.' '*' ')' ';' timeunits_declaration? module_item* 'endmodule' (':' module_identifier)?,
    'extern' module_nonansi_header,
    'extern' module_ansi_header,
};
module_nonansi_header = attribute_instance* module_keyword lifetime? module_identifier package_import_declaration* parameter_port_list? list_of_ports ';';
module_ansi_header = attribute_instance* module_keyword lifetime? module_identifier package_import_declaration* parameter_port_list? list_of_port_declarations? ';';
module_keyword = {'module', 'macromodule'};
interface_declaration = {
    interface_nonansi_header timeunits_declaration? interface_item* 'endinterface' (':' interface_identifier)?,
    interface_ansi_header timeunits_declaration? non_port_interface_item* 'endinterface' (':' interface_identifier)?,
    attribute_instance* 'interface' interface_identifier '(' '.' '*' ')' ';' timeunits_declaration? interface_item* 'endinterface' (':' interface_identifier)?,
    'extern' interface_nonansi_header,
    'extern' interface_ansi_header,
};
interface_nonansi_header = attribute_instance* 'interface' lifetime? interface_identifier package_import_declaration* parameter_port_list? list_of_ports ';';
interface_ansi_header = attribute_instance* 'interface' lifetime? interface_identifier package_import_declaration* parameter_port_list? list_of_port_declarations? ';';
program_declaration = {
    program_nonansi_header timeunits_declaration? program_item* 'endprogram' (':' program_identifier)?,
    program_ansi_header timeunits_declaration? non_port_program_item* 'endprogram' (':' program_identifier)?,
    attribute_instance* 'program' program_identifier '(' '.' '*' ')' ';' timeunits_declaration? program_item* 'endprogram' (':' program_identifier)?,
    'extern' program_nonansi_header,
    'extern' program_ansi_header,
};
program_nonansi_header = attribute_instance* 'program' lifetime? program_identifier package_import_declaration* parameter_port_list? list_of_ports ';';
program_ansi_header = attribute_instance* 'program' lifetime? program_identifier package_import_declaration* parameter_port_list? list_of_port_declarations? ';';
checker_declaration = 'checker' checker_identifier ('(' checker_port_list? ')')? ';' checker_or_generate_item* 'endchecker' (':' checker_identifier)?;
class_declaration = 'virtual'? 'class' lifetime? class_identifier parameter_port_list? ('extends' class_type ('(' list_of_arguments ')')?)? ';' class_item* 'endclass' (':' class_identifier)?;
package_declaration = attribute_instance* 'package' lifetime? package_identifier ';' timeunits_declaration? (attribute_instance* package_item)* 'endpackage' (':' package_identifier);
timeunits_declaration = {
    'timeunit' time_literal ('/' time_literal)? ';',
    'timeprecision' time_literal ';',
    'timeunit' time_literal ';' 'timeprecision' time_literal ';',
    'timeprecision' time_literal ';' 'timeunit' time_literal ';',
};

// A.1.3 Module parameters and ports

parameter_port_list = {
    '#' '(' list_of_param_assignments (',' parameter_port_declaration)* ')',
    '#' '(' parameter_port_declaration (',' parameter_port_declaration)* ')',
    '#' '(' ')',
};
parameter_port_declaration = {
    parameter_declaration,
    local_parameter_declaration,
    data_type list_of_param_assignments,
    'type' list_of_type_assignments,
};
list_of_ports = '(' attribute_instance*! port (',' attribute_instance*! port)* ')';
list_of_port_declarations = '(' (attribute_instance* ansi_port_declaration (',' attribute_instance* ansi_port_declaration)*)? ')';
port_declaration = {
    attribute_instance* inout_declaration,
    attribute_instance* input_declaration,
    attribute_instance* output_declaration,
    attribute_instance* ref_declaration,
    attribute_instance* interface_port_declaration,
};
port = {
    port_expression?,
    '.' port_identifier '(' port_expression? ')',
};
port_expression = {
    port_reference,
    '{' port_reference (',' port_reference)* '}',
};
port_reference = port_identifier constant_select;
port_direction = {'input', 'output', 'inout', 'ref'};
net_port_header = port_direction? net_port_type;
variable_port_header = port_direction? variable_port_type;
interface_port_header = {
    interface_identifier ('.' modport_identifier)?,
    'interface' ('.' modport_identifier)?,
};
ansi_port_declaration = {
    net_or_interface_port_header? port_identifier unpacked_dimension* ('=' constant_expression)?,
    variable_port_header? port_identifier variable_dimension* ('=' constant_expression)?,
    port_direction? '.' port_identifier '(' expression? ')',
};
net_or_interface_port_header = {net_port_header, interface_port_header};

// A.1.4 Module items

elaboration_system_task = {
    '$fatal' ('(' finish_number (',' list_of_arguments)? ')')? ';',
    '$error' ('(' list_of_arguments ')')? ';',
    '$warning' ('(' list_of_arguments ')')? ';',
    '$info' ('(' list_of_arguments ')')? ';',
};
finish_number = {'0', '1', '2'};
module_common_item = {
    module_or_generate_item_declaration,
    interface_instantiation,
    program_instantiation,
    assertion_item,
    bind_directive,
    continuous_assign,
    net_alias,
    initial_construct,
    final_construct,
    always_construct,
    loop_generate_construct,
    conditional_generate_construct,
    elaboration_system_task,
};
module_item = { port_declaration ';', non_port_module_item };
module_or_generate_item = {
    attribute_instance* parameter_override,
    attribute_instance* gate_instantiation,
    attribute_instance* udp_instantiation,
    attribute_instance* module_instantiation,
    attribute_instance* module_common_item,
};
module_or_generate_item_declaration = {
    package_or_generate_item_declaration,
    genvar_declaration,
    clocking_declaration,
    'default' 'clocking' clocking_identifier ';',
    'default' 'disable' 'iff' expression_or_dist ';',
};
non_port_module_item = {
    generate_region,
    module_or_generate_item,
    specify_block,
    attribute_instance* specparam_declaration,
    program_declaration,
    module_declaration,
    interface_declaration,
    timeunits_declaration,
};
parameter_override = 'defparam' list_of_defparam_assignments ';';
bind_directive = {
    'bind' bind_target_scope (':' bind_target_instance_list)? bind_instantiation ';',
    'bind' bind_target_instance bind_instantiation ';',
};
bind_target_scope = { module_identifier, interface_identifier };
bind_target_instance = hierarchical_identifier constant_bit_select;
bind_target_instance_list = bind_target_instance (',' bind_target_instance)*;
bind_instantiation = {
    program_instantiation,
    module_instantiation,
    interface_instantiation,
    checker_instantiation,
};

// A.1.6 Interface items

interface_or_generate_item = {
    attribute_instance* module_common_item,
    attribute_instance* modport_declaration,
    attribute_instance* extern_tf_declaration,
};
extern_tf_declaration = {
    'extern' method_prototype ';',
    'extern' 'forkjoin' task_prototype ';',
};
interface_item = { port_declaration ';', non_port_interface_item };
non_port_interface_item = {
    generate_region,
    interface_or_generate_item,
    program_declaration,
    interface_declaration,
    timeunits_declaration,
};

// A.1.7 Program items

program_item = { port_declaration ';', non_port_program_item };
non_port_program_item = {
    attribute_instance* continuous_assign,
    attribute_instance* module_or_generate_item_declaration,
    attribute_instance* initial_construct,
    attribute_instance* final_construct,
    attribute_instance* concurrent_assertion_item,
    attribute_instance* timeunits_declaration,
    program_generate_item,
};
program_generate_item = {
    loop_generate_construct,
    conditional_generate_construct,
    generate_region,
    elaboration_system_task,
};

// A.1.8 Checker items

checker_port_list = checker_port_item (',' checker_port_item)*;
checker_port_item = attribute_instance* property_formal_type port_identifier variable_dimension* ('=' property_actual_arg)?;
checker_or_generate_item = {
    checker_or_generate_item_declaration,
    initial_construct,
    checker_always_construct,
    final_construct,
    assertion_item,
    checker_generate_item,
};
checker_or_generate_item_declaration = {
    'rand'? data_declaration,
    function_declaration,
    assertion_item_declaration,
    covergroup_declaration,
    overload_declaration,
    genvar_declaration,
    clocking_declaration,
    'default' 'clocking' clocking_identifier ';',
    'default' 'disable' 'iff' expression_or_dist ';',
    ';',
};
checker_generate_item = {
    loop_generate_construct,
    conditional_generate_construct,
    generate_region,
    elaboration_system_task,
};
checker_always_construct = { 'always' statement };

// A.1.9 Class items

class_item = {
    attribute_instance* class_property,
    attribute_instance* class_method,
    attribute_instance* class_constraint,
    attribute_instance* class_declaration,
    attribute_instance* covergroup_declaration,
    local_parameter_declaration ';',
    parameter_declaration ';',
    ';',
};
class_property = {
    property_qualifier* data_declaration,
    'const' class_item_qualifier* data_type const_identifier ('=' constant_expression)? ';',
};
class_method = {
    method_qualifier* task_declaration,
    method_qualifier* function_declaration,
    'extern' method_qualifier* method_prototype ';',
    method_qualifier* class_constructor_declaration,
    'extern' method_qualifier* class_constructor_prototype,
};
class_constructor_prototype = 'function' 'new' '(' tf_port_list? ')' ';' ;
class_constraint = { constraint_prototype, constraint_declaration };
class_item_qualifier = { 'static', 'protected', 'local' };
property_qualifier = { random_qualifier, class_item_qualifier };
random_qualifier = { 'rand', 'randc' };
method_qualifier = { 'pure'? 'virtual', class_item_qualifier };
method_prototype = { task_prototype, function_prototype };
class_constructor_declaration = 'function' class_scope? 'new' ('(' tf_port_list? ')')? ';' block_item_declaration* ('super' '.' 'new' ('(' list_of_arguments ')')? ';')? function_statement_or_null* 'endfunction' (':' 'new')?;

// A.1.10 Constraints

constraint_declaration = 'static'? 'constraint' constraint_identifier constraint_block;
constraint_block = '{' constraint_block_item* '}';
constraint_block_item = {
    'solve' solve_before_list 'before' solve_before_list ';',
    constraint_expression,
};
solve_before_list = solve_before_primary (',' solve_before_primary)*;
solve_before_primary = {
    hierarchical_identifier select,
    implicit_class_handle '.' hierarchical_identifier select,
    class_scope hierarchical_identifier select,
};
constraint_expression = {
    expression_or_dist ';',
    expression '–>' constraint_set,
    'if' '(' expression ')' constraint_set ('else' constraint_set)?,
    'foreach' '(' ps_or_hierarchical_array_identifier '[' loop_variables ']' ')' constraint_set,
};
constraint_set = { constraint_expression, '{' constraint_expression* '}' };
dist_list = dist_item (',' dist_item);
dist_item = value_range dist_weight?;
dist_weight = { ':=' expression, ':/' expression };
constraint_prototype = constraint_prototype_qualifier? 'static'? 'constraint' constraint_identifier ';';
constraint_prototype_qualifier = { 'extern', 'pure' };
extern_constraint_declaration = 'static'? 'constraint' class_scope constraint_identifier constraint_block;
identifier_list = identifier (',' identifier)*;

// A.1.11 Package items

package_item = {
    package_or_generate_item_declaration,
    anonymous_program,
    package_export_declaration,
    timeunits_declaration,
};
package_or_generate_item_declaration = {
    net_declaration,
    data_declaration,
    task_declaration,
    function_declaration,
    checker_declaration,
    dpi_import_export,
    extern_constraint_declaration,
    class_declaration,
    class_constructor_declaration,
    local_parameter_declaration ';',
    parameter_declaration ';',
    covergroup_declaration,
    overload_declaration,
    assertion_item_declaration,
    ';',
};
anonymous_program = 'program' ';' anonymous_program_item* 'endprogram';
anonymous_program_item = {
    task_declaration,
    function_declaration,
    class_declaration,
    covergroup_declaration,
    class_constructor_declaration,
    ';',
};

//////////////////////////
//   A.2 Declarations   //
//////////////////////////

// A.2.1 Declaration types

// A.2.1.1 Module parameter declarations

local_parameter_declaration = {
    'localparam' data_type_or_implicit list_of_param_assignments,
    'localparam' type list_of_type_assignments,
};
parameter_declaration = {
    'parameter' data_type_or_implicit list_of_param_assignments,
    'parameter' type list_of_type_assignments,
};
specparam_declaration = 'specparam' packed_dimension? list_of_specparam_assignments ';';

// A.2.1.2 Port declarations

inout_declaration = 'inout' net_port_type list_of_port_identifiers;
input_declaration = {
    'input' net_port_type list_of_port_identifiers,
    'input' variable_port_type list_of_variable_identifiers,
};
output_declaration = {
    'output' net_port_type list_of_port_identifiers,
    'output' variable_port_type list_of_variable_port_identifiers,
};
interface_port_declaration = {
    interface_identifier list_of_interface_identifiers,
    interface_identifier '.' modport_identifier list_of_interface_identifiers,
};
ref_declaration = 'ref' variable_port_type list_of_port_identifiers;

// A.2.1.3 Type declarations

data_declaration = {
    'const'? 'var'? lifetime? data_type_or_implicit list_of_variable_decl_assignments ';',
    type_declaration,
    package_import_declaration,
    virtual_interface_declaration,
};
package_import_declaration = 'import' package_import_item (',' package_import_item)* ';';
package_import_item = { package_identifier '::' identifier, package_identifier '::' '*' };
package_export_declaration = {
    'export' '*' '::' '*' ';',
    'export' package_import_item (',' package_import_item)* ';',
};
genvar_declaration = 'genvar' list_of_genvar_identifiers ';';
net_declaration = net_type (drive_strength | charge_strength)? ('vectored' | 'scalared')? data_type_or_implicit delay3? list_of_net_decl_assignments ';';
type_declaration = {
    'typedef' data_type type_identifier variable_dimension* ';',
    'typedef' interface_instance_identifier constant_bit_select '.' type_identifier type_identifier ';',
    'typedef' ('enum' | 'struct' | 'union' | 'class')? type_identifier ';',
};
lifetime = { 'static', 'automatic' };

// A.2.2 Declaration data types

// A.2.2.1 Net and variable types

casting_type = { simple_type, constant_primary, signing, 'string', 'const' };
data_type = {
    integer_vector_type signing? packed_dimension*,
    integer_atom_type signing?,
    non_integer_type,
    struct_union ('packed' signing?)? '{' struct_union_member+ '}' packed_dimension*,
    'enum' enum_base_type? '{' enum_name_declaration (',' enum_name_declaration)* '}' packed_dimension*,
    'string',
    'chandle',
    'virtual' 'interface'? interface_identifier,
    (class_scope | package_scope)? type_identifier packed_dimension*,
    class_type,
    'event',
    ps_covergroup_identifier,
    type_reference,
};
data_type_or_implicit = { data_type, implicit_data_type };
implicit_data_type = signing? packed_dimension*;
enum_base_type = {
    integer_atom_type signing?,
    integer_vector_type signing? packed_dimension?,
    type_identifier packed_dimension?,
};
enum_name_declaration = enum_identifier ('[' integral_number (':' integral_number)? ']')? ('=' constant_expression)?;
class_scope = class_type '::';
class_type = ps_class_identifier parameter_value_assignment? ('::' class_identifier parameter_value_assignment?)*;
integer_vector_type = { 'bit', 'logic', 'reg' };
integer_atom_type = { 'byte', 'shortint', 'int', 'longint', 'integer', 'time' };
non_integer_type = { 'shortreal', 'real', 'realtime' };
net_type = { 'supply0', 'supply1', 'tri', 'triand', 'trior', 'trireg', 'tri0', 'tri1', 'uwire', 'wire', 'wand', 'wor' };
net_port_type = net_type? data_type_or_implicit;
variable_port_type = var_data_type;
var_data_type = { data_type, 'var' data_type_or_implicit };
signing = { 'signed', 'unsigned' };
simple_type = { integer_type, non_integer_type, ps_type_identifier, ps_parameter_identifier };
struct_union_member = attribute_instance* random_qualifier? data_type_or_void list_of_variable_decl_assignments ';';
data_type_or_void = { data_type, 'void' };
struct_union = { 'struct', 'union' 'tagged'? };
type_reference = {
    'type' '(' expression ')',
    'type' '(' data_type ')',
};

// A.2.2.2 Strengths

drive_strength = {
    '(' strength0 ',' strength1 ')',
    '(' strength1 ',' strength0 ')',
    '(' strength0 ',' 'highz1' ')',
    '(' strength1 ',' 'highz0' ')',
    '(' 'highz0' ',' strength1 ')',
    '(' 'highz1' ',' strength0 ')',
};
strength0 = { 'supply0', 'strong0', 'pull0', 'weak0' };
strength1 = { 'supply1', 'strong1', 'pull1', 'weak1' };
charge_strength = {
    '(' 'small' ')',
    '(' 'medium' ')',
    '(' 'large' ')',
};

// A.2.2.3 Delays

delay3 = {
    '#' delay_value,
    '#' '(' mintypmax_expression (',' mintypmax_expression (',' mintypmax_expression)?)? ')',
};
delay2 = {
    '#' delay_value,
    '#' '(' mintypmax_expression (',' mintypmax_expression)? ')',
};
delay_value = {
    unsigned_number,
    real_number,
    ps_identifier,
    time_literal,
    '1step',
};

// A.2.3 Declaration lists

list_of_defparam_assignments = defparam_assignment (',' defparam_assignment)*;
list_of_genvar_identifiers = genvar_identifier (',' genvar_identifier)*;
list_of_interface_identifiers = interface_identifier unpacked_dimension* (',' interface_identifier unpacked_dimension*)*;
list_of_net_decl_assignments = net_decl_assignment (',' net_decl_assignment)*;
list_of_param_assignments = param_assignment (',' param_assignment)*;
list_of_port_identifiers = port_identifier unpacked_dimension* (',' port_identifier unpacked_dimension*)*;
list_of_udp_port_identifiers = port_identifier (',' port_identifier)*;
list_of_specparam_assignments = specparam_assignment (',' specparam_assignment)*;
list_of_tf_variable_identifiers = port_identifier variable_dimension* ('=' expression)? (',' port_identifier variable_dimension* ('=' expression)?)*;
list_of_type_assignments = type_assignment (',' type_assignment)*;
list_of_variable_decl_assignments = variable_decl_assignment (',' variable_decl_assignment)*;
list_of_variable_identifiers = variable_identifier variable_dimension* (',' variable_identifier variable_dimension*)*;
list_of_variable_port_identifiers = port_identifier variable_dimension* ('=' constant_expression)? (',' port_identifier variable_dimension* ('=' constant_expression)?)*;
list_of_virtual_interface_decl = variable_identifier ('=' interface_instance_identifier)? (',' variable_identifier ('=' interface_instance_identifier)?)*;

// A.2.4 Declaration assignments

defparam_assignment = hierarchical_parameter_identifier '=' constant_mintypmax_expression;
net_decl_assignment = net_identifier unpacked_dimension* ('=' expression)?;
param_assignment = parameter_identifier unpacked_dimension* ('=' constant_param_expression)?;
specparam_assignment = { specparam_identifier '=' constant_mintypmax_expression, pulse_control_specparam };
type_assignment = type_identifier ('=' data_type);
pulse_control_specparam = {
    'PATHPULSE$' '=' '(' reject_limit_value (',' error_limit_value) ')',
    'PATHPULSE$' specify_input_terminal_descriptor '$' specify_output_terminal_descriptor '=' '(' reject_limit_value (',' error_limit_value)? ')',
};
error_limit_value = limit_value;
reject_limit_value = limit_value;
limit_value = constant_mintypmax_expression;
variable_decl_assignment = {
    variable_identifier variable_dimension* ('=' expression)?,
    dynamic_array_variable_identifier unsized_dimension variable_dimension* ('=' dynamic_array_new)?,
    class_variable_identifier ('=' class_new)?,
};
class_new = {
    'new',
    'new' '(' list_of_arguments ')',
    'new' expression,
};
dynamic_array_new = 'new' '[' expression ']' ('(' expression ')')?;

// A.2.5 Declaration ranges

unpacked_dimension = { '[' constant_range ']', '[' constant_expression ']' };
packed_dimension = { '[' constant_range ']', unsized_dimension };
associative_dimension = { '[' data_type ']', '[' '*' ']' };
variable_dimension = {
    unsized_dimension,
    unpacked_dimension,
    associative_dimension,
    queue_dimension,
};
queue_dimension = '[' '$' (':' constant_expression)? ']';
unsized_dimension = '[' ']';

// A.2.6 Function declarations

function_data_type_or_implicit = { data_type_or_void, implicit_data_type };
function_declaration = 'function' lifetime? function_body_declaration;
function_body_declaration = {
    function_data_type_or_implicit (interface_identifier '.' | class_scope)? function_identifier ';' tf_item_declaration* function_statement_or_null* 'endfunction' (':' function_identifier)?,
    function_data_type_or_implicit (interface_identifier '.' | class_scope)? function_identifier '(' tf_port_list? ')' ';' block_item_declaration* function_statement_or_null* 'endfunction' (':' function_identifier)?,
};
function_prototype = 'function' data_type_or_void function_identifier '(' tf_port_list? ')';
dpi_import_export = {
    'import' dpi_spec_string dpi_function_import_property? (c_identifier '=')? dpi_function_proto ';',
    'import' dpi_spec_string dpi_task_import_property? (c_identifier '=')? dpi_task_proto ';',
    'export' dpi_spec_string (c_identifier '=')? function function_identifier ';',
    'export' dpi_spec_string (c_identifier '=')? task task_identifier ';',
};
dpi_spec_string = { '"DPI-C"', '"DPI"' };
dpi_function_import_property = { 'context', 'pure' };
dpi_task_import_property = 'context';
dpi_function_proto = function_prototype;
dpi_task_proto = task_prototype;

// A.2.7 Task declarations

task_declaration = 'task' lifetime? task_body_declaration;
task_body_declaration = {
    (interface_identifier '.' | class_scope)? task_identifier ';' tf_item_declaration* statement_or_null* 'endtask' (':' task_identifier)?,
    (interface_identifier '.' | class_scope)? task_identifier '(' tf_port_list? ')' ';' block_item_declaration* statement_or_null* 'endtask' (':' task_identifier)?,
};
tf_item_declaration = { block_item_declaration, tf_port_declaration };
tf_port_list = tf_port_item (',' tf_port_item)*;
tf_port_item = attribute_instance* tf_port_direction? 'var'? data_type_or_implicit (port_identifier variable_dimension* ('=' expression)?)?;
tf_port_direction = { port_direction, 'const' 'ref' };
tf_port_declaration = attribute_instance* tf_port_direction 'var' data_type_or_implicit list_of_tf_variable_identifiers ';';
task_prototype = 'task' task_identifier '(' tf_port_list? ')';

// A.2.8 Block item declarations
block_item_declaration = {
    attribute_instance* data_declaration,
    attribute_instance* local_parameter_declaration ';',
    attribute_instance* parameter_declaration ';',
    attribute_instance* overload_declaration,
    attribute_instance* let_declaration,
};
overload_declaration = 'bind' overload_operator 'function' data_type function_identifier '(' overload_proto_formals ')' ';';
overload_operator = { '+', '++', '–', '– –', '*', '**', '/', '%', '==', '!=', '<', '<=', '>', '>=', '=' };
overload_proto_formals = data_type (',' data_type)*;

// A.2.9 Interface declarations

virtual_interface_declaration = 'virtual' 'interface'? interface_identifier parameter_value_assignment? ('.' modport_identifier)? list_of_virtual_interface_decl ';';
modport_declaration = 'modport' modport_item (',' modport_item)* ';';
modport_item = modport_identifier '(' modport_ports_declaration (',' modport_ports_declaration)* ')';
modport_ports_declaration = {
    attribute_instance* modport_simple_ports_declaration,
    attribute_instance* modport_tf_ports_declaration,
    attribute_instance* modport_clocking_declaration,
};
modport_clocking_declaration = 'clocking' clocking_identifier;
modport_simple_ports_declaration = port_direction modport_simple_port (',' modport_simple_port)*;
modport_simple_port = { port_identifier, '.' port_identifier '(' expression? ')' };
modport_tf_ports_declaration = import_export modport_tf_port (',' modport_tf_port)*;
modport_tf_port = { method_prototype, tf_identifier };
import_export = { 'import', 'export' };

// A.2.10 Assertion declarations

concurrent_assertion_item = {
    (block_identifier ':')? concurrent_assertion_statement,
    checker_instantiation,
};
concurrent_assertion_statement = {
    assert_property_statement,
    assume_property_statement,
    cover_property_statement,
    cover_sequence_statement,
    restrict_property_statement,
};
assert_property_statement = 'assert' 'property' '(' property_spec ')' action_block;
assume_property_statement = 'assume' 'property' '(' property_spec ')' action_block;
cover_property_statement = 'cover' 'property' '(' property_spec ')' statement_or_null;
expect_property_statement = 'expect' '(' property_spec ')' action_block;
cover_sequence_statement = 'cover' 'sequence' '(' clocking_event? ('disable' 'iff' '(' expression_or_dist ')')? sequence_expr ')' statement_or_null;
restrict_property_statement = 'restrict' 'property' '(' property_spec ')' ';';
property_instance = ps_or_hierarchical_property_identifier ('(' property_list_of_arguments? ')')?;
property_list_of_arguments = {
    property_actual_arg? (',' property_actual_arg?)* (',' '.' identifier '(' property_actual_arg? ')')*,
    '.' identifier '(' property_actual_arg? ')' (',' '.' identifier '(' property_actual_arg? ')')*,
};
property_actual_arg = { property_expr, sequence_actual_arg };
assertion_item_declaration = { property_declaration, sequence_declaration, let_declaration };
property_declaration = 'property' property_identifier ('(' property_port_list? ')')? ';' assertion_variable_declaration* property_statement_spec 'endproperty' (':' property_identifier)?;
property_port_list = property_port_item (',' property_port_item)*;
property_port_item = attribute_instance* ('local' property_lvar_port_direction?)? property_formal_type port_identifier variable_dimension* ('=' property_actual_arg)?;
property_lvar_port_direction = 'input';
property_formal_type = { sequence_formal_type, 'property' };
property_spec = clocking_event? ('disable' 'iff' '(' expression_or_dist ')')? property_expr;
property_statement_spec = clocking_event? ('disable' 'iff' '(' expression_or_dist ')')? property_statement;
property_statement = {
    property_expr ';',
    'case' '(' expression_or_dist ')' property_case_item+ 'endcase',
    'if' '(' expression_or_dist ')' property_expr ('else' property_expr)*,
};
property_case_item = {
    expression_or_dist (',' expression_or_dist)* ':' property_statement,
    'default' ':'? property_statement,
};
property_expr = {
    sequence_expr,
    'strong' '(' sequence_expr ')',
    'weak' '(' sequence_expr ')',
    '(' property_expr ')',
    'not' property_expr,
    property_expr 'or' property_expr,
    property_expr 'and' property_expr,
    sequence_expr '|->' property_expr,
    sequence_expr '|=>' property_expr,
    property_statement,
    sequence_expr '#-#' property_expr,
    sequence_expr '#=#' property_expr,
    'nexttime' property_expr,
    'nexttime' '[' constant _expression ']' property_expr,
    's_nexttime' property_expr,
    's_nexttime' '[' constant_expression ']' property_expr,
    'always' property_expr,
    'always' '[' cycle_delay_const_range_expression ']' property_expr,
    's_always' '[' constant_range ']' property_expr,
    's_eventually' property_expr,
    'eventually' '[' constant_range ']' property_expr,
    's_eventually' '[' cycle_delay_const_range_expression ']' property_expr,
    property_expr 'until' property_expr,
    property_expr 's_until' property_expr,
    property_expr 'until_with' property_expr,
    property_expr 's_until_with' property_expr,
    property_expr 'implies' property_expr,
    property_expr 'iff' property_expr,
    'accept_on' '(' expression_or_dist ')' property_expr,
    'reject_on' '(' expression_or_dist ')' property_expr,
    'sync_accept_on' '(' expression_or_dist ')' property_expr,
    'sync_reject_on' '(' expression_or_dist ')' property_expr,
    property_instance,
    clocking_event property_expr,
};
sequence_declaration = 'sequence' sequence_identifier ('(' sequence_port_list? ')')? ';' assertion_variable_declaration* sequence_expr ';' 'endsequence' (':' sequence_identifier)?;
sequence_port_list = sequence_port_item (',' sequence_port_item)*;
sequence_port_item = attribute_instance* ('local' sequence_lvar_port_direction?)? sequence_formal_type port_identifier variable_dimension* ('=' sequence_actual_arg)?;
sequence_lvar_port_direction = { 'input', 'inout', 'output' };
sequence_formal_type = { data_type_or_implicit, 'sequence', 'event', 'untyped' };
sequence_expr = {
    (cycle_delay_range sequence_expr)+,
    sequence_expr (cycle_delay_range sequence_expr)+,
    expression_or_dist boolean_abbrev?,
    sequence_instance sequence_abbrev?,
    '(' sequence_expr (',' sequence_match_item)* ')' sequence_abbrev?,
    sequence_expr 'and' sequence_expr,
    sequence_expr 'intersect' sequence_expr,
    sequence_expr 'or' sequence_expr,
    'first_match' '(' sequence_expr (',' sequence_match_item)* ')',
    expression_or_dist 'throughout' sequence_expr,
    sequence_expr 'within' sequence_expr,
    clocking_event sequence_expr,
};
cycle_delay_range = {
    '##' constant_primary,
    '##' '[' cycle_delay_const_range_expression ']',
    '##' '[' '*' ']',
    '##' '[' '+' ']',
};
sequence_method_call = sequence_instance '.' method_identifier;
sequence_match_item = { operator_assignment, inc_or_dec_expression, subroutine_call };
sequence_instance = ps_or_hierarchical_sequence_identifier ('(' sequence_list_of_arguments? ')')?;
sequence_list_of_arguments = {
    sequence_actual_arg? (',' sequence_actual_arg?)* (',' '.' identifier '(' sequence_actual_arg? ')')*,
    '.' identifier '(' sequence_actual_arg? ')' (',' '.' identifier '(' sequence_actual_arg? ')')*,
};
sequence_actual_arg = { event_expression, sequence_expr };
boolean_abbrev = { consecutive_repetition, non_consecutive_repetition, goto_repetition };
sequence_abbrev = consecutive_repetition;
consecutive_repetition = {
    '[' '*' const_or_range_expression ']',
    '[' '*' ']',
    '[' '+' ']',
};
non_consecutive_repetition = '[' '=' const_or_range_expression ']';
goto_repetition = '[' '->' const_or_range_expression ']';
const_or_range_expression = { constant_expression, cycle_delay_const_range_expression };
cycle_delay_const_range_expression = {
    constant_expression ':' constant_expression,
    constant_expression ':' '$',
};
expression_or_dist = expression ('dist' '{' dist_list '}')?;
assertion_variable_declaration = var_data_type list_of_variable_decl_assignments ';';
let_declaration = 'let' let_identifier ('(' let_port_list? ')')? '=' expression ';';
let_identifier = identifier;
let_port_list = let_port_item (',' let_port_item)*;
let_port_item = attribute_instance* let_formal_type port_identifier variable_dimension* ('=' expression)?;
let_formal_type = data_type_or_implicit;
let_expression = package_scope? let_identifier ('(' let_list_of_arguments? ')')?;
let_list_of_arguments = {
    let_actual_arg? (',' let_actual_arg?)* (',' '.' identifier '(' let_actual_arg? ')')*,
    '.' identifier '(' let_actual_arg? ')' (',' '.' identifier '(' let_actual_arg? ')')*,
};
let_actual_arg = expression;

// -----------------------------------------------------------------------------

expression = identifier;
attribute_instance = 'ATTR';
integral_number = '123';
identifier = 'IDENT';
list_of_arguments = {
    expression? (',' expression?)? (',' '.' identifier '(' expression? ')')*,
    '.' identifier '(' expression? ')' (',' '.' identifier '(' expression? ')')*,
};

// t10 = {
//     '$' n49,
//     '*',
//     constant_expression,
//     constant_range,
//     data_type,
// };

/////////////////////////
//   A.8 Expressions   //
/////////////////////////

// A.8.3 Expressions
constant_expression = {
    constant_primary,
    unary_operator attribute_instance* constant_primary,
    constant_expression binary_operator attribute_instance* constant_expression,
    constant_expression '?' attribute_instance* constant_expression ':' constant_expression,
};
constant_range = constant_expression ':' constant_expression;

// A.8.4 Primaries
constant_primary = {
    primary_literal,
    ps_parameter_identifier constant_select,
    genvar_identifier,
    type_reference,
};
primary = {
    primary_literal,
    'this',
    '$',
    'null',
};
primary_literal = { number, time_literal, unbased_unsized_literal, string_literal };

// A.9.3 Identifiers
class_identifier = identifier;
class_variable_identifier = identifier;
covergroup_identifier = identifier;
dynamic_array_variable_identifier = identifier;
genvar_identifier = identifier;
interface_identifier = identifier;
module_identifier = identifier;
package_identifier = identifier;
package_scope = { package_identifier '::', '$unit' '::' };
parameter_identifier = identifier;
type_identifier = identifier;
variable_identifier = identifier;
ps_class_identifier = package_scope? class_identifier;
ps_parameter_identifier = package_scope? parameter_identifier;
ps_covergroup_identifier = package_scope? covergroup_identifier;
